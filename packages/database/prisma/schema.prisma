generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}


enum ProviderName{
  GOOGLE
  GITHUB
}


model User {
  id               String            @id @default(uuid())
  email            String?           @unique
  avatar_url       String?           
  created_at       DateTime          @default(now())
  display_name     String?           
  last_login_at    DateTime?
  profile_url      String?
  username         String 

  contributions    Contribution[]
  recommendedRepos RecommendedRepo[]
  refreshTokens    RefreshToken[]
  userRepoStats    UserRepoStat[]
  providers        Provider[]
  repositories     Repository[]
}

model Provider {
  id             String   @id @default(uuid())
  provider       ProviderName
  providerUserId String   
  accessTokenEnc String?
  createdAt      DateTime @default(now())

  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerUserId])
  @@index([userId])
}

model RefreshToken {
  id        String   @id @default(uuid())
  tokenHash String
  expiresAt DateTime
  createdAt DateTime @default(now())

  userId    String
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
}

model Repository {
  id                String   @id @default(uuid())
  github_repo_id    String   @unique
  owner_login       String
  owner_id          Int
  owner_profile_url String
  name              String
  full_name         String   @unique
  html_url          String
  description       String?
  primary_language  String?
  stars_count       Int      @default(0)
  forks_count       Int      @default(0)
  open_issues_count Int      @default(0)
  topics            String[] @default([])
  is_fork           Boolean  @default(false)
  is_private        Boolean  @default(false)
  last_pushed_at    DateTime?

  userId            String?
  user              User?    @relation(fields: [userId], references: [id], onDelete: Cascade)

  contributions     Contribution[]
  recommendedRepos  RecommendedRepo[]
  fetchHistory      RepoFetchHistory[]
  userRepoStats     UserRepoStat[]

  @@index([userId])
}


model Contribution {
  id              String     @id @default(uuid())
  user_id         String
  repo_id         String
  type            String
  github_event_id String?
  event_url       String?
  event_date      DateTime?
  details         Json?
  created_at      DateTime   @default(now())
  updated_at      DateTime   @updatedAt

  repo            Repository @relation(fields: [repo_id], references: [id])
  user            User       @relation(fields: [user_id], references: [id])

  @@unique([user_id, repo_id])

}

model UserRepoStat {
  id              String     @id @default(uuid())
  user_id         String
  repo_id         String
  total_commits   Int        @default(0)
  total_prs       Int        @default(0)
  total_issues    Int        @default(0)
  last_updated_at DateTime   @default(now()) 

  repo            Repository @relation(fields: [repo_id], references: [id])
  user            User       @relation(fields: [user_id], references: [id])

  @@unique([user_id, repo_id])
}

model RecommendedRepo {
  id             String       @id @default(uuid())
  user_id        String
  repo_id        String
  score          Float?
  recommended_at DateTime   @default(now())
  tags_matched   Json?

  repo           Repository @relation(fields: [repo_id], references: [id])
  user           User       @relation(fields: [user_id], references: [id])
}

model RepoFetchHistory {
  id           String     @id @default(uuid())
  repo_id      String
  fetched_at   DateTime   @default(now())
  status       String
  raw_metadata Json?

  repo         Repository @relation(fields: [repo_id], references: [id])
}


